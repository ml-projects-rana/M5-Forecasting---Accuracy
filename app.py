# -*- coding: utf-8 -*-
"""flask.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gKeDtMjQRPBbr0f6PNNanb6bOToQEfj9
"""

import pandas as pd
import pickle
import numpy as np
import random 
import warnings
warnings.filterwarnings("ignore")
import time
from sklearn.preprocessing import LabelEncoder
from flask import Flask,request,jsonify,render_template,abort,make_response 

app = Flask(__name__)

calendar_=pd.read_csv('calendar.csv')
sales_train_evaluation_=pd.read_csv('sales_train_evaluation.csv')
sell_prices_=pd.read_csv('sell_prices.csv')

total_items=sales_train_evaluation_['item_id'].unique().tolist()
total_stores=sales_train_evaluation_['store_id'].unique().tolist()


def function_1(x):
    #Adding columns for the days d_1942 to d_1969 as nan for which we need to forecast sales
    for i in range(1942,1970):
        x['d_'+str(i)]=np.nan
        x['d_'+str(i)]=x['d_'+str(i)].astype(np.float16)
    
    #Melting
    #To make analysis of data in table easier we can reshape the data into a more computer-friendly form using pandas in Python. 
    #pandas.melt() is one of the function to do so
    df=pd.melt(x,id_vars=['id','item_id','dept_id','cat_id','store_id','state_id'],var_name='d',value_name='demand')
    df=pd.merge(df,calendar_,on='d',how='left')
    df=pd.merge(df,sell_prices_,on=['item_id','store_id','wm_yr_wk'],how='left')

    #Since we got many rows with 'NaN' values in Sell Price
    #Thus replacing 'NaN" in 'sell_price' feature with the mean value
    df['sell_price']=df['sell_price'].fillna(df.groupby('id')['sell_price'].transform('mean'))

    #Converting Object Data Type to Category Data Type
    col=list(df.columns)
    types=list(df.dtypes.values)
    for i,j in enumerate(types):
        if j.name == 'object':
            df[col[i]]=df[col[i]].astype('category')
    
    #Replacing 'NaN' values by 'no_event'
    cat=['event_name_1','event_type_1','event_name_2','event_type_2']
    for i in cat:
        df[i]=df[i].cat.add_categories('no_event')
        df[i].fillna('no_event',inplace=True)
    
    #Adding feature 'is_weekend' which tells about that day is weekend or not
    f=lambda x: 1 if x<=2 else 0
    #https://stackoverflow.com/questions/21608228/conditional-replace-pandas
    df['is_weekend']=df['wday'].map(f) 
    df['is_weekend']=df['is_weekend'].astype(np.int8)
    
    #Adding feature 'month_day' which tells day of the month
    m=df["date"].tolist()
    m=[i.split("-")[2] for i in m]
    df["month_day"]=m
    df['month_day']=df['month_day'].astype(np.int8)
    
    #Adding feature 'month_week_number' which tells which week of the month
    #https://stackoverflow.com/questions/3806473/python-week-number-of-the-month
    df['month_week_number']=(df['month_day']-1) // 7 + 1  
    df['month_week_number']=df['month_week_number'].astype(np.int8)
    
    #Adding feature 'events_per_day' which tells us number of events on particular day
    f=lambda x: 0 if x=='no_event' else 1
    #https://stackoverflow.com/questions/21608228/conditional-replace-pandas
    df['events_per_day']=df['event_type_1'].map(f)
    index=df.index 
    indices=index[df['event_type_2']!='no_event'].tolist()
    for i in indices:
        df['events_per_day'][i]+=1
        df['events_per_day']=df['events_per_day'].astype(np.int8)

    #Lag features are the classical way that time series forecasting problems are transformed into supervised learning problems.
    #Lag is expressed in a time unit & corresponds to the amount of data history we allow the model to use when making the prediction.
    #Here we have applied Lags on 'demand' column.
    #The maximum Lags taken is 70 days
    lags=[28,35,42,49,56,63,70]
    for i in lags:
        df['lag_'+str(i)]=df.groupby(['id'])['demand'].shift(i)

    #Replacing 'NaN' in 'lags' features with 0
    lags=['lag_28','lag_35','lag_42','lag_49','lag_56','lag_63','lag_70']
    for i in lags:
        df[i]=df[i].fillna(0) 
    
    #Rolling is a very useful operation for time series data.
    #Here we have computing Rolling-Mean on 'demand' column.
    #The maximum Window size taken is 42
    #https://stackoverflow.com/questions/13996302/python-rolling-functions-for-groupby-object
    #https://www.geeksforgeeks.org/python-pandas-dataframe-transform/
    window=[7,14,28,35,42]
    for i in window:
        df['rolling_median_'+str(i)]=df.groupby(['id'])['demand'].transform(lambda s: s.rolling(i,center=False).median())

    #Replacing 'NaN' in 'rolling_ mean' features with 0
    window=['rolling_median_7','rolling_median_14','rolling_median_28','rolling_median_35','rolling_median_42']
    for i in window:
        df[i]=df[i].fillna(0) 

    #Encoding refers to converting the labels into numeric form so as to convert it into the machine-readable form.
    #Machine learning algorithms can then decide in a better way on how those labels must be operated.
    #It is an important pre-processing step for the structured dataset in supervised learning
    #https://www.mygreatlearning.com/blog/label-encoding-in-python/
    labelencoder=LabelEncoder() 
    category=['event_name_1','event_type_1','event_name_2','event_type_2','id','item_id','dept_id','cat_id','store_id','state_id']
    for i in category:
        df[i+'_']=labelencoder.fit_transform(df[i])

    #Drop all the categorical columns bcoz we already added coresponding columns with label-encoding
    df=df.drop(['event_name_1','event_type_1','event_name_2','event_type_2','id','item_id','dept_id','cat_id','store_id','state_id'],axis=1)

    #Removed '_' from 'd' column values so that we can convert Categorical feature into Numerical feature easily
    l=[]
    for i in df['d']:
        l.append(i.split('_')[1])
    df['day']=l
    #https://stackoverflow.com/questions/15891038/change-column-type-in-pandas
    df['day']=df['day'].astype(np.int16) 

    #Since 'weekday' is represented by 'wday' & 'd' is represented by 'day'
    #We already have 'month','year' thats why 'date' is also duplicate column
    df=df.drop(['d','date','weekday'],axis=1)

    df=df.drop(['demand'],axis=1)
    
    #Taken data after 1000 days (d_1000) so that processing speed will be fast (last approx. 31 months data)
    df=df[df['day']>1000]

    #Divide data into Test/Validation
    #Validation: From d_1914 to d_1942
    #Test: From d_1942 to d_1970
    l=[]
    for i in range(1914,1942):
        l.append(i)
    x_valid=df.loc[df['day'].isin(l)]
    x_test=df.loc[df['day']>=1942]

    #Loading Already Trained LightGBM Regressor Model for Computaion 
    with open('lgb_model.pkl','rb') as f:
        lgb=pickle.load(f)

    pred_test=pd.DataFrame()
    pred_test['id']=x['id'] 
    j=1
    k=1
    for i in range(1942,1970):
        pred_test['F'+str(k)]=lgb.predict(x_test[x_test['day']==(i)]) 
        k+=1
        
    return np.round(pred_test,2)
  
def evaluate(p,s):
    sales=sales_train_evaluation_.loc[sales_train_evaluation_['item_id']==p]
    sales=sales.loc[sales['store_id']==s]
    pred_sales=function_1(sales)
    pred_sales=pred_sales.values.reshape(-1).tolist()[1:]
    x=pd.date_range(start="2016-05-23",end="2016-06-19")
    #https://www.programiz.com/python-programming/datetime/strftime
    month=x.strftime("%m").tolist()
    day=x.strftime("%d").tolist()
    m=[]
    for i in month:
        if i =='05':
          m.append('May')
        else:
          m.append('June')
    x=[]
    for i in range(len(day)):
        t='2016'+' '+m[i]+' '+day[i]
        x.append(t)
    z=zip(x,pred_sales)
    return (z)


@app.route('/')
def home():
    return render_template('home.html')    

@app.route('/predict',methods=["GET","POST"])
def predict():
    if request.method == "POST":
        # getting input with name = product in HTML form
        p=request.form.get("product")
        # getting input with name = store in HTML form 
        s=request.form.get("store") 
        
        #If 'item_id' & 'store_id' entered by user persent in total_items & total_stores respectively.
        #Than only estimate sales otherwise Invalid ID
        if (p in total_items) and (s in total_stores):
            z=evaluate(p,s)
            return render_template('estimate.html',x=z,store=s,item=p) 
        
        else:
            response=make_response(jsonify(message=" Either PRODUCT ID or STORE ID is Invalid. Please Enter Valid Details "),406)
            abort(response)
            

if __name__ == "__main__":
    app.run()

